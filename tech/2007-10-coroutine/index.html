<!doctype html><html lang=mn><head><meta charset=utf-8><meta name=generator content="Hugo 0.81.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=twitter:card content="summary"><meta name=twitter:title content="Coroutine - Ochko"><meta name=twitter:description content="Coroutine бол жирийн функц процедурын өргөтгөсөн хэлбэр юм. Функцүүд нэг эхлэлтэй байдаг, өөрөөр хэлбэл функцыг дуудахад эхний мөрөөсөө эхлэн ажилладаг. Харин Coroutine нь олон эхлэлтэй байж болно. Юу гэсэн үг вэ гэвэл, Coroutine-ийг дуудах болгонд өөр өөр мөрөөс эхлэн ажиллаж болдог гэсэн үг. Иймд бидний өдөр тутам хэрэглэдэг функц процедурууд нь Coroutine-ийн нэгэн эгэл тохиолдол.
Нэгэн жишээ авч үзье. Фибоначийн тоонууд гэдэг нь дарааллын гишүүн нь өмнөх хоёрынхоо нийлбэрээр тодорхойлогддог тоонууд юм."><meta name=twitter:site content="https://ochko.github.io"><meta name=twitter:creator content="L.Ochirkhuyag"><meta name=twitter:image content="https://ochko.github.io/images/koen-stripe.jpg"><meta property="og:locale" content><meta property="og:type" content="article"><meta property="og:title" content="Coroutine - Ochko"><meta property="og:description" content="Coroutine бол жирийн функц процедурын өргөтгөсөн хэлбэр юм. Функцүүд нэг эхлэлтэй байдаг, өөрөөр хэлбэл функцыг дуудахад эхний мөрөөсөө эхлэн ажилладаг. Харин Coroutine нь олон эхлэлтэй байж болно. Юу гэсэн үг вэ гэвэл, Coroutine-ийг дуудах болгонд өөр өөр мөрөөс эхлэн ажиллаж болдог гэсэн үг. Иймд бидний өдөр тутам хэрэглэдэг функц процедурууд нь Coroutine-ийн нэгэн эгэл тохиолдол.
Нэгэн жишээ авч үзье. Фибоначийн тоонууд гэдэг нь дарааллын гишүүн нь өмнөх хоёрынхоо нийлбэрээр тодорхойлогддог тоонууд юм."><meta property="og:url" content="https://ochko.github.io/tech/2007-10-coroutine/"><meta property="og:site_name" content="Ochko"><meta property="og:image" content="https://ochko.github.io/images/koen-stripe.jpg"><meta name=author content="L.Ochirkhuyag"><meta name=description content="Coroutine бол жирийн функц процедурын өргөтгөсөн хэлбэр юм. Функцүүд нэг эхлэлтэй байдаг, өөрөөр хэлбэл функцыг дуудахад эхний мөрөөсөө эхлэн ажилладаг. Харин Coroutine нь олон эхлэлтэй байж болно. Юу гэсэн үг вэ гэвэл, Coroutine-ийг дуудах болгонд өөр өөр мөрөөс эхлэн ажиллаж болдог гэсэн үг. Иймд бидний өдөр тутам хэрэглэдэг функц процедурууд нь Coroutine-ийн нэгэн эгэл тохиолдол.
Нэгэн жишээ авч үзье. Фибоначийн тоонууд гэдэг нь дарааллын гишүүн нь өмнөх хоёрынхоо нийлбэрээр тодорхойлогддог тоонууд юм."><title>Coroutine :: Ochko</title><link rel=stylesheet href=https://ochko.github.io/main.c69c2099423661dd79e10cf8ebb2b25c1fd68ad72813dd5e35dd25d82a3f08d7.css></head><body class=antialiased><div class="container mx-auto py-4 px-4 sm:px-6 lg:px-8 min-h-screen flex flex-col"><header class=mb-8><nav class="flex space-x-4" aria-label=Tabs><a href=/><img class="inline-block h-12 w-12 rounded-full ml-2 mr-6" src=https://ochko.github.io/images/koen-stripe.jpg alt=L.Ochirkhuyag></a>
<a href=https://ochko.github.io/posts/ class="text-gray-500 hover:text-gray-700 px-3 my-2 py-2 font-medium text-sm rounded-md">Personal Blog</a>
<a href=https://ochko.github.io/tech/ class="bg-gray-100 text-gray-500 hover:text-gray-700 px-3 my-2 py-2 font-medium text-sm rounded-md">Tech stuff</a></nav></header><div class="flex-1 pt-10"><article class="prose max-w-none"><h1>Coroutine</h1><time class="text-sm text-right text-gray-600" datetime="2007-10-11 19:42:00 +08">2007-10-11</time><div class=pt-4><p>Coroutine бол жирийн функц процедурын өргөтгөсөн хэлбэр юм. Функцүүд нэг эхлэлтэй байдаг, өөрөөр хэлбэл функцыг дуудахад эхний мөрөөсөө эхлэн ажилладаг. Харин Coroutine нь олон эхлэлтэй байж болно. Юу гэсэн үг вэ гэвэл, Coroutine-ийг дуудах болгонд өөр өөр мөрөөс эхлэн ажиллаж болдог гэсэн үг. Иймд бидний өдөр тутам хэрэглэдэг функц процедурууд нь Coroutine-ийн нэгэн эгэл тохиолдол.</p><p>Нэгэн жишээ авч үзье. Фибоначийн тоонууд гэдэг нь дарааллын гишүүн нь өмнөх хоёрынхоо нийлбэрээр тодорхойлогддог тоонууд юм. Мэдээж эхний 2 тоо нь өгөгдөх ёстой.</p><p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610,&mldr;</p><p>Дуудах болгонд нэг фибоначийн тоо өгдөг функцийг ruby дээр бичвэл:</p><pre><code>fib = Fiber.new do  
  x, y = 0, 1  
  loop do  
    Fiber.yield y  
    x,y = y,x+y  
  end  
end  
  
20.times { puts fib.resume }  

```Энэ функцыг дуудах болгонд дараагийн фибоначийн тоог буцаах болно. Учир нь resume -ээр дуудах болгонд функц yield гэсэн хэсгээс үргэлжлэн ажилладаг. Дараах хуурмаг C кодыг харья.  
</code></pre><p>int coroutine Generate_1_2_3() {<br>yield 1; /* Execution begins here upon first call to Generate123 */<br>yield 2; /* execution continues here upon &ldquo;resume Generate123&rdquo; */<br>yield 3; /* execution continues here upon second &ldquo;resume Generate123&rdquo; */<br>}</p><p>main() {<br>printf("%d\n", Generate_1_2_3()); /* prints &ldquo;1&rdquo; */<br>printf("%d\n", resume Generate_1_2_3()); /* prints &ldquo;2&rdquo; */<br>printf("%d\n", resume Generate_1_2_3()); /* prints &ldquo;3&rdquo; */<br>}</p><pre><code class=language-Дээрхи data-lang=Дээрхи>  
Coroutine-ийг ихэвчлэн Thread-тэй харьцуулж үздэг. Thread-ээс давуу тал нь гэвэл deadlock, synchronization гэх мэт асуудлууд байхгүй. Гэхдээ мэдээж Thread бол зэрэг ажилладаг учраас түүгээрээ давуу.  
  
Coroutine нь State machine програмчлах, ямар нэгэн дараалсан зүйлсийг үүсгэх, өмнөх фибоначийн жишээ шиг төгсгөлгүй цуваа зэрэгт хэрэглэгддэг. Заримдаа нилээн хүнд бодлогуудыг coroutine ашиглаад хялбархан шийдэх тохиолдол байдаг. Жишээ нь &quot;[Ижил хөвөөний бодлого](http://c2.com/cgi/wiki?SameFringeProblem)&quot;: Хоёр ширхэг хоёртын модны бүх навчнууд зүүнээсээ баруун хүртлээ харгалзан ижил байвал тэр хоёр модыг ижил хөвөөтэй гэнэ. Өгөгдсөн хоёр модыг ижил хөвөөтэй эсэхийг шалга.  
  
Энэ бодлогыг Lua хэл дээр шийдсэн нь:  
</code></pre><p>function tree_leaves(tree)<br>if tree.leaf then<br>coroutine.yield(tree.leaf)<br>else<br>tree_leaves(tree.left)<br>tree_leaves(tree.right)<br>end<br>end</p><p>function same_fringe(tree1, tree2)<br>local iter1 = coroutine.wrap(tree_leaves)<br>local iter2 = coroutine.wrap(tree_leaves)<br>for node in iter1, tree1 do<br>if node ~= iter2(tree2) then<br>return false<br>end<br>end<br>return iter2() == nil<br>end</p><pre><code class=language-Coroutine data-lang=Coroutine>  
Зарим coroutine -г дэмжсэн програмчлалын хэлүүд:  

*   [Ruby](http://www.ruby-lang.org/)
*   [Python](http://www.python.org/)
*   [Lua](http://www.lua.org/)
*   [Perl](http://www.perl.org/)

Хэрэгцээтэй хуудсууд:  

*   [Википедиа дээрхи тайлбар](http://en.wikipedia.org/wiki/Coroutine)  
    
*   [Товч тодорхойлолт болон, Coroutine дэмждэг хэлүүдийг жагсаалт](http://webseitz.fluxent.com/wiki/CoRoutine)  
    
*   [С хэл дээр хэрхэн хэрэгжүүлж болох тухай](http://www.chiark.greenend.org.uk/%7Esgtatham/coroutines.html)  
    
*   [C++ дээр coroutine нэмэх](http://www.akira.ruc.dk/%7Ekeld/research/COROUTINE/)  
    
*   [CoRoutine Товч танилцуулга](http://c2.com/cgi/wiki?CoRoutine)</code></pre></div></article></div><footer class="mt-12 text-xs">&copy; 2006-2021 L.Ochirkhuyag</footer></div></body></html>